_shift,^shift = press shift, release shift?
- begin when key down, end when key up?
 - <mode>.<action> = <key combo>
 - normal-mode.to.mouse-mode=_ctrl,^ctrl,_ctrl,^ctrl
 - mouse-mode.to.temp-mouse-mode=_ctrl,^ctrl
 - temp-mouse-mode.to.normal-mode=_ctrl,^ctrl
 - mouse-mode.press-left=_shift
 - mouse-mode.release-left=^shift
 - mouse-mode.start-move-left=_leftarrow
 - mouse-mode.stop-move-left=^leftarrow
 - mouse-mode.mouse-acceleration, wheel.acceleration
 - mouse-mode.indicator.color=red
- temp-mouse-mode.timeout.duration=1s # automatically changes mode if no key combo was detected during 1s and no action is currently running (e.g. move-up)
- temp-mouse-mode.timeout.next-mode=normal-mode
- temp-mouse-mode.oneshot.next-mode=normal-mode # once an action has run (e.g. move-up), mode changes automatically
- Can assign multiple combo to same action
 - mouse-mode.press-left=_lshift
 - mouse-mode.press-left=_rshift
- Can assign one combo to multiple actions
 - normal-mode.to.mouse-mode=_leftarrow,^leftarrow,_leftarrow
 - normal-mode.start-move-left=_leftarrow,^leftarrow,_leftarrow
- Non-last keys involved in a combo should not be eaten
 - Reason is Up, Up: if only press single up, the Up,Up combo should not eat the first Up
 - The last key event of the combo should be eaten
 - In _ctrl,_/ the / should be eaten only if ctrl was pressed (i.e. combo is being prepared)
 - Ctrl-A,B == _ctrl _a ^ctrl ^a _b and _ctrl _a ^a ^ctrl _b
 - Could do complex combo like hold ctrl, then a, then a again: _ctrl _a ^a _a ^a
 - combo timeout = time after which we stop waiting for a combo to be completed (150ms,?)
 - A combo has to be non-interrupted (no unknown key presses), with at most 150ms between keys
  - Large timeout to allow Ctrl, wait, Z. Or special __ctrl to indicate no timeout. Or no timeout at all?
- Should a keyevent unrelated to a combo break the combo preparation? Yes.
 - Released event cannot be eaten if Pressed event was not eaten, otherwise apps will bug
  -- Need user to specify which event should not be eaten (eaten by normal)
 - Should a reached combo reset the preparation (no combo accumulation)? No. Maybe. No.
  -- Imagine Ctrl+up/down moves the mouse. We want to be able to hold Ctrl, (wait long) then up/down
   - This should be done with a mode (enabled with Ctrl)
  - _arrow,^arrow,_arrow should enable mouse mode and move up
   - Done by defining move-up in both normal-mode and mouse-mode
  - _arrow,^arrow,_arrow,^arrow,(some time)_arrow should enable mouse mode then move up
  - _arrow,^arrow,_arrow,^arrow,_arrow should enable mouse mode then scroll up
- Combo(List<KeyAction>), KeyAction(Key, KeyState=PRESSED,RELEASED)
 - KeyEvent(time, action)
 - Preparation(List<KeyEvent> events)
  - Reset when last key event is not a prefix of any combo
 - Preparation.isPrefixOf(Combo)
- Speed should not change when overlapping press-left/press-right. Speed set to 0 when all released.
 - On overlaps (press-left/press-right), last action wins (need a stack push/pop)
- ^{shift up|shift down} +rightctrl mean shift and up, and shift down should not be pressed when
  this combo (+rightctrl) starts
- getkeystate to reset pressed keys after 10s
 - On windows lock screen, I hit space then enter the pin. Space press is recorded by the app but the
   corresponding release is never received, never removed from currentlyPressedKeys. This blocks the app.
- toggle logging?
+ teleport key should use current display size percentage: not if we go from one screen to another
 + Name it move-left-by instead of teleport-left
 + mouse.move-by-offset=300
+ vimium-like hint (warpd), keynav-like grid?
+ position history
+ Move mouse to center of focused app?
- Hide cursor after 5s
 - uncluttered-mouse-mode.hide-cursor.enabled+idle-duration
 - timeout.duration -> idle-duration
 - Add timeout.enabled
- Rename OsManager to Platform
- Check LLKHF_INJECTED?
- Min/max values for grid row/column count
- Do not inherit SwitchMode commands with mode.extend
+ Keynav grid (2 rows x 2 columns grid)
 + Grid could have arbitrary number of rows/columns (for snapping), but the grid cuts and shifts are done on 2x2
 - Snap instead of grid?
 + Reset/Show grid to full screen, fixed-size around current mouse position, around focused window
  + create-full-screen-grid, create-active-window-grid, create-around-cursor-grid
   + grid.around-cursor-grid-width/height
   + press rightctrl -> temp-snap-mode
   + temp-snap-mode -> idle timeout 0.2s -> grid-mode
   + temp-snap-mode -> arrow key -> perm-snap-mode
   + press rightctrl -> snap-mode -> release rightctrl -> mouse-mode
   + temp-snap-mode -> quick release rightctrl -> normal mode
   + grid-mode -> release rightctrl -> mouse-mode
  + If leftctrl also pressed then focused window grid, if leftshift then around current pos
  + also moves mouse to grid center: move-to-grid-center-when-created=true
 + Hide grid (cannot disable a grid?)
  + If try to use grid commands while grid is hidden/not initialized, create a new full screen grid
 + Snap to grid lines (mouse can be outside grid) snap-left
 + Move to grid center
 - Half (cut in half) grid in a direction (cut-grid-top/bottom/left/right)
  - arrow keys
  - Also moves to grid center automatically: move-to-grid-center-when-cut=true
 + Shift grid: shift-grid-top
  + arrow keys with rightctrl
  + move-to-grid-center-when-shifted
  + If grid already touches screen edge, then move grid to closest monitor
   + Resize too fullscreen if grid bigger than new monitor
 + Teleport forward to +300px is snapping to (or shifting) the around-cursor grid?
  + The corresponding grid window should be movable to a neighbor monitor
 + OS-dependent code should access model code, not the opposite