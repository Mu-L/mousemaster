_shift,^shift = press shift, release shift?
- begin when key down, end when key up?
 - <mode>.<action> = <key combo>
 - normal-mode.to.normal-mode=_ctrl,^ctrl,_ctrl,^ctrl
 - normal-mode.to.temp-normal-mode=_ctrl,^ctrl
 - temp-normal-mode.to.normal-mode=_ctrl,^ctrl
 - normal-mode.press-left=_shift
 - normal-mode.release-left=^shift
 - normal-mode.start-move-left=_leftarrow
 - normal-mode.stop-move-left=^leftarrow
 - normal-mode.mouse-acceleration, wheel.acceleration
 - normal-mode.indicator.color=red
- temp-normal-mode.timeout.duration=1s # automatically changes mode if no key combo was detected during 1s and no action is currently running (e.g. move-up)
- temp-normal-mode.timeout.next-mode=normal-mode
- temp-normal-mode.oneshot.next-mode=normal-mode # once an action has run (e.g. move-up), mode changes automatically
- Can assign multiple combo to same action
 - normal-mode.press-left=_lshift
 - normal-mode.press-left=_rshift
- Can assign one combo to multiple actions
 - normal-mode.to.normal-mode=_leftarrow,^leftarrow,_leftarrow
 - normal-mode.start-move-left=_leftarrow,^leftarrow,_leftarrow
- Non-last keys involved in a combo should not be eaten
 - Reason is Up, Up: if only press single up, the Up,Up combo should not eat the first Up
 - The last key event of the combo should be eaten
 - In _ctrl,_/ the / should be eaten only if ctrl was pressed (i.e. combo is being prepared)
 - Ctrl-A,B == _ctrl _a ^ctrl ^a _b and _ctrl _a ^a ^ctrl _b
 - Could do complex combo like hold ctrl, then a, then a again: _ctrl _a ^a _a ^a
 - combo timeout = time after which we stop waiting for a combo to be completed (150ms,?)
 - A combo has to be non-broken (no unknown key presses), with at most 150ms between keys
  - Large timeout to allow Ctrl, wait, Z. Or special __ctrl to indicate no timeout. Or no timeout at all?
- Should a keyevent unrelated to a combo break the combo preparation? Yes.
 - Released event cannot be eaten if Pressed event was not eaten, otherwise apps will bug
  -- Need user to specify which event should not be eaten (eaten by normal)
 - Should a reached combo reset the preparation (no combo accumulation)? No. Maybe. No.
  -- Imagine Ctrl+up/down moves the mouse. We want to be able to hold Ctrl, (wait long) then up/down
   - This should be done with a mode (enabled with Ctrl)
  - _arrow,^arrow,_arrow should enable mouse mode and move up
   - Done by defining move-up in both normal-mode and normal-mode
  - _arrow,^arrow,_arrow,^arrow,(some time)_arrow should enable mouse mode then move up
  - _arrow,^arrow,_arrow,^arrow,_arrow should enable mouse mode then scroll up
- Combo(List<KeyAction>), KeyAction(Key, KeyState=PRESSED,RELEASED)
 - KeyEvent(time, action)
 - Preparation(List<KeyEvent> events)
  - Reset when last key event is not a prefix of any combo
 - Preparation.isPrefixOf(Combo)
- Speed should not change when overlapping press-left/press-right. Speed set to 0 when all released.
 - On overlaps (press-left/press-right), last action wins (need a stack push/pop)
- ^{shift up|shift down} +rightctrl mean shift and up, and shift down should not be pressed when
  this combo (+rightctrl) starts
- getkeystate to reset pressed keys after 10s
 - On windows lock screen, I hit space then enter the pin. Space press is recorded by the app but the
   corresponding release is never received, never removed from currentlyPressedKeys. This blocks the app.
- toggle logging?
+ teleport key should use current display size percentage: not if we go from one screen to another
 + Name it move-left-by instead of teleport-left
 + mouse.move-by-offset=300
+ vimium-like hint (warpd), keynav-like grid?
+ Move mouse to center of focused app?
- Hide cursor after 5s
 - uncluttered-normal-mode.hide-cursor.enabled+idle-duration
 - timeout.duration -> idle-duration
 - Add timeout.enabled
- Rename OsManager to Platform
- Check LLKHF_INJECTED?
- Min/max values for grid row/column count
- Do not inherit SwitchMode commands with mode.extend
+ Keynav grid (2 rows x 2 columns grid)
 + Grid could have arbitrary number of rows/columns (for snapping), but the grid cuts and shifts are done on 2x2
 - Snap instead of grid?
 + Reset/Show grid to full screen, fixed-size around current mouse position, around focused window
  + create-full-screen-grid, create-active-window-grid, create-follow-mouse-grid
   - grid.follow-mouse-grid-width/height
   - press rightctrl -> temp-snap-mode
   - temp-snap-mode -> idle timeout 0.2s -> grid-mode
   - temp-snap-mode -> arrow key -> perm-snap-mode
   - press rightctrl -> snap-mode -> release rightctrl -> normal-mode
   - temp-snap-mode -> quick release rightctrl -> normal-mode
   - grid-mode -> release rightctrl -> normal-mode
  + If leftctrl also pressed then focused window grid, if leftshift then around current pos
  + also moves mouse to grid center: move-to-grid-center-when-created=true
 + Hide grid (cannot disable a grid?)
  + If try to use grid commands while grid is hidden/not initialized, create a new full screen grid
 - Snap to grid lines (mouse can be outside grid) snap-left
 - Half (cut in half) grid in a direction (cut-grid-top/bottom/left/right)
  - arrow keys
  - Also moves to grid center automatically: move-to-grid-center-when-cut=true
 - Shift grid: move-grid-top
  - arrow keys with rightctrl
  - move-to-grid-center-when-shifted
  - If grid already touches screen edge, then move grid to closest monitor
   - Resize too fullscreen if grid bigger than new monitor
 - Teleport forward to +300px is snapping to (or moving-grid) the follow-mouse grid?
  - The corresponding grid window should be movable to a neighbor monitor
 + Exit gracefully when exception thrown (e.g. infinite switch mode loop)
 - Rename shift-grid to move-grid
 - Put back update() in IndicatorManager for updating the color
 - When moving/snapping grid to edge of screen, check if there is a monitor containing grid center
  - If not, keep grid in current monitor
 - Move to grid center (need separate command)
  - mouse-follows-grid-center should not initially synchronize the mouse
   - _{rightctrl} move-to-grid-center: does not work for modes triggered after idle timeout
  - mouse-follows-grid-center-except-when-grid-created?
 - synchronization=mouse-follows-grid-center / grid-center-follows-mouse / mouse-and-grid-center-unsynchronized
  - grid.type->area = active-screen 1.0 1.0, active-window 1.0 1.0
 - Rename snapRow/ColumnCount to row/ColumnCount
 + IndicatorManager should listen for mouse position and give it to WindowsIndicator
 + Hints
  + Grid hints (hints on the current grid, which can be a fullscreen or active window or around mouse grid)
  + Screen hints = one-hint-per-screen-mode (one per screen)
  + Grid type: active-screen (instead of full screen) and all-screens
  + all-screens: WindowsOverlay.setGrid(List<Grid>)
  + One hint per grid cell
  + Screen selection = all-screens grid with row/column count 1
    + In all screen grid, cannot move grid or cut grid (but can snap)
  - Hint selection is like cutting the grid to a specific cell
   - mode.grid.end.cut-count = 2 to have 2-phase hint selection
    - grid.end.next-mode
    - Or: mode.grid.next-mode-after-cut=smaller-grid-around-cursor-mode
     - switch-to-mode-after-grid-cut=new-mode
     - mode.switch-mode-after-hint-selected-=...
     - or mode.to.new-mode=once-hint-selected
  - Regular hint = active-screen-hints-mode = active-screen grid with row/column count 20 20
  - grid.row-count=hint-key-count
  - If hint key count == row and column count, then 2-key hints in order (aa, ab, ac, etc.)
  - If hint key count > hint count (e.g. screen selection) then 1-key hints
  - Else: Find hintLength, hintCount = hintKeyCount^hintLength >= rowCount*columnCount
  - grid.hint-enabled=false/true
  - Split hint into its own class HintManager
   + hint.area=active-screen, active-window, all-screens
- Give a chance to _{} ^{} combos when mode switched? No
 + Dragging: normal-mode -> press left -> hint mode (handles left release key) -> normal-mode
+ Update hint windows when monitors changed?
+ History (positions previously selected through hints)
 + grid.area/row-count -> grid.layout=position-history | active-screen 0.99 0.99 2(rowCount) 2
  + Grid with variable-size rows and columns
  + Each historical position is the center of one cell
  + Compute the midpoints between consecutive hint positions, that is the cell width/height
  + Or one mini 1x1 grid per historical position
- normal-mode -> idle-mode
+ Rename Mouse, Wheel, etc. to Mouse/Wheel/...Configuration
+ mode.blinking-mouse.enabled/visible-duration/invisible-duration
- Change pause-combo-processing-when-mode-activated to when-mode-exited and simplify absolute-snap-mode
 - Remove it completely? Ignore switch-mode combo if mode has already been changed?

- No UI (just a command line app that loads the configuration from a file)
- Seamlessly move mouse across screens (like mouseable does)
- Configuration file is automatically reloaded when changes are saved to it
- Distinguish between left and right alt/ctrl/shift keys
- Keyboard layout-aware
- Can have an indicator next to the mouse (or not), with different colors for when idling, moving, pressing buttons, and scrolling
- The indicator will re-position itself when the mouse is close to the edges of the screen so that it stays visible
- Configuration of keys is done in terms of key press and key release events, and whether the key events should be passed onto other apps or not.
  This allows for defining advanced key combos, but at the cost of added complexity of the configuration file
- Each command (e.g. start-move-left) is triggered by one or more key combos
- The same key combo can be used to trigger multiple commands. This can be used to do many things including "click and disable".
- The user defines modes. There is only one predefined mode, the "idle-mode" which has no key combos defined (i.e. this is the "Xxx is disabled mode").
- Each mode has its own (command -> key combo) map.
- Each mode can have its own mouse and wheel configuration (initial velocity, max velocity, acceleration).
  This can be used to create "slow" and "fast" modes.
- A timeout can be set on a mode to switch to another mode after some idle time
 (this can be used for disabling Xxx after a while, hiding the indicator after a while, etc.)
- This way of defining key combos and modes can be used to implement "toggle dragging",
  chain commands (e.g. if your move combos are arrow keys while holding ctrl, you can move left/right without releasing ctrl)
- Grids. Grid area
- Can use mode to implement hints (e.g. a b c d ... z), and click-after-hint-selected when holding shift
- Position history: multi-screen position history hints (I believe warpd has position history hints for a single screen only)
- The major structural differences with mouseable and warpd are the way key combos are defined
  (key presses and key releases instead of "just keys"), and the "create your own modes" approach.
  A mode is not restricted to "just normal mouse movements" or "just grid" or "just hints".
- The configuration is more complex than warpd/mouseable, mostly because you have to think in terms of key presses and key releases.
- It's Windows only, I have not looked at making it cross-platform simply because I don't have an incentive for doing so
  (all my desktops are Windows based).
