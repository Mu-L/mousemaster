_shift,^shift = press shift, release shift?
- begin when key down, end when key up?
 - <mode>.<action> = <key combo>
 - normal-mode.to.mouse-mode=_ctrl,^ctrl,_ctrl,^ctrl
 - mouse-mode.to.temp-mouse-mode=_ctrl,^ctrl
 - temp-mouse-mode.to.normal-mode=_ctrl,^ctrl
 - mouse-mode.press-left=_shift
 - mouse-mode.release-left=^shift
 - mouse-mode.start-move-left=_leftarrow
 - mouse-mode.stop-move-left=^leftarrow
 - mouse-mode.mouse-acceleration, wheel.acceleration
 - mouse-mode.indicator.color=red
- temp-mouse-mode.timeout.duration=1s # automatically changes mode if no key combo was detected during 1s and no action is currently running (e.g. move-up)
- temp-mouse-mode.timeout.next-mode=normal-mode
- temp-mouse-mode.oneshot.next-mode=normal-mode # once an action has run (e.g. move-up), mode changes automatically
- Can assign multiple combo to same action
 - mouse-mode.press-left=_lshift
 - mouse-mode.press-left=_rshift
- Can assign one combo to multiple actions
 - normal-mode.to.mouse-mode=_leftarrow,^leftarrow,_leftarrow
 - normal-mode.start-move-left=_leftarrow,^leftarrow,_leftarrow
- Non-last keys involved in a combo should not be eaten
 - Reason is Up, Up: if only press single up, the Up,Up combo should not eat the first Up
 - The last key event of the combo should be eaten
 - In _ctrl,_/ the / should be eaten only if ctrl was pressed (i.e. combo is being prepared)
 - Ctrl-A,B == _ctrl _a ^ctrl ^a _b and _ctrl _a ^a ^ctrl _b
 - Could do complex combo like hold ctrl, then a, then a again: _ctrl _a ^a _a ^a
 - combo timeout = time after which we stop waiting for a combo to be completed (150ms,?)
 - A combo has to be non-broken (no unknown key presses), with at most 150ms between keys
  - Large timeout to allow Ctrl, wait, Z. Or special __ctrl to indicate no timeout. Or no timeout at all?
- Should a keyevent unrelated to a combo break the combo preparation? Yes.
 - Released event cannot be eaten if Pressed event was not eaten, otherwise apps will bug
  -- Need user to specify which event should not be eaten (eaten by normal)
 - Should a reached combo reset the preparation (no combo accumulation)? No. Maybe. No.
  -- Imagine Ctrl+up/down moves the mouse. We want to be able to hold Ctrl, (wait long) then up/down
   - This should be done with a mode (enabled with Ctrl)
  - _arrow,^arrow,_arrow should enable mouse mode and move up
   - Done by defining move-up in both normal-mode and mouse-mode
  - _arrow,^arrow,_arrow,^arrow,(some time)_arrow should enable mouse mode then move up
  - _arrow,^arrow,_arrow,^arrow,_arrow should enable mouse mode then scroll up
- Combo(List<KeyAction>), KeyAction(Key, KeyState=PRESSED,RELEASED)
 - KeyEvent(time, action)
 - Preparation(List<KeyEvent> events)
  - Reset when last key event is not a prefix of any combo
 - Preparation.isPrefixOf(Combo)
- Speed should not change when overlapping press-left/press-right. Speed set to 0 when all released.
 - On overlaps (press-left/press-right), last action wins (need a stack push/pop)
- ^{shift up|shift down} +rightctrl mean shift and up, and shift down should not be pressed when
  this combo (+rightctrl) starts
- getkeystate to reset pressed keys after 10s
 - On windows lock screen, I hit space then enter the pin. Space press is recorded by the app but the
   corresponding release is never received, never removed from currentlyPressedKeys. This blocks the app.
- toggle logging?
+ teleport key should use current display size percentage: not if we go from one screen to another
 + Name it move-left-by instead of teleport-left
 + mouse.move-by-offset=300
+ vimium-like hint (warpd), keynav-like grid?
+ position history
+ Move mouse to center of focused app?
- Hide cursor after 5s
 - uncluttered-mouse-mode.hide-cursor.enabled+idle-duration
 - timeout.duration -> idle-duration
 - Add timeout.enabled
- Rename OsManager to Platform
- Check LLKHF_INJECTED?
- Min/max values for grid row/column count
- Do not inherit SwitchMode commands with mode.extend
+ Keynav grid (2 rows x 2 columns grid)
 + Grid could have arbitrary number of rows/columns (for snapping), but the grid cuts and shifts are done on 2x2
 - Snap instead of grid?
 + Reset/Show grid to full screen, fixed-size around current mouse position, around focused window
  + create-full-screen-grid, create-active-window-grid, create-follow-mouse-grid
   - grid.follow-mouse-grid-width/height
   - press rightctrl -> temp-snap-mode
   - temp-snap-mode -> idle timeout 0.2s -> grid-mode
   - temp-snap-mode -> arrow key -> perm-snap-mode
   - press rightctrl -> snap-mode -> release rightctrl -> mouse-mode
   - temp-snap-mode -> quick release rightctrl -> normal mode
   - grid-mode -> release rightctrl -> mouse-mode
  + If leftctrl also pressed then focused window grid, if leftshift then around current pos
  + also moves mouse to grid center: move-to-grid-center-when-created=true
 + Hide grid (cannot disable a grid?)
  + If try to use grid commands while grid is hidden/not initialized, create a new full screen grid
 - Snap to grid lines (mouse can be outside grid) snap-left
 - Half (cut in half) grid in a direction (cut-grid-top/bottom/left/right)
  - arrow keys
  - Also moves to grid center automatically: move-to-grid-center-when-cut=true
 - Shift grid: move-grid-top
  - arrow keys with rightctrl
  - move-to-grid-center-when-shifted
  - If grid already touches screen edge, then move grid to closest monitor
   - Resize too fullscreen if grid bigger than new monitor
 - Teleport forward to +300px is snapping to (or moving-grid) the follow-mouse grid?
  - The corresponding grid window should be movable to a neighbor monitor
 + Exit gracefully when exception thrown (e.g. infinite switch mode loop)
 - Rename shift-grid to move-grid
 - Put back update() in IndicatorManager for updating the color
 - When moving/snapping grid to edge of screen, check if there is a monitor containing grid center
  - If not, keep grid in current monitor
 + Move to grid center (need separate command)
 + synchronization=mouse-follows-grid-center / grid-center-follows-mouse / mouse-and-grid-center-unsynchronized
  + grid.type->area = active-screen 1.0 1.0, active-window 1.0 1.0
 + IndicatorManager should listen for mouse position and give it to WindowsIndicator
 + Hints
  + Grid hints (hints on the current grid, which can be a fullscreen or active window or around mouse grid)
  + Screen hints = one-hint-per-screen-mode (one per screen)
  + Grid type: active-screen (instead of full screen) and all-screens
  + all-screens: WindowsOverlay.setGrid(List<Grid>)
  + One hint per grid cell
  + Screen selection = all-screens grid with row/column count 1
    + In all screen grid, cannot move grid or cut grid (but can snap)
  + Regular hint = active-screen-hints-mode = active-screen grid with row/column count 20 20
  + grid.row-count=hint-character-count
  + If hint character count == row and column count, then 2-character hints in order (aa, ab, ac, etc.)
  + If hint character count > hint count (e.g. screen selection) then 1-character hints
  + Else: Find hintLength, hintCount = hintCharacterCount^hintLength >= rowCount*columnCount
  + grid.hint-enabled=false/true

- No UI (just a command line app that loads the configuration from a file)
- Seamlessly move mouse across screens (mouseable does it, warpd does not)
- Configuration file is reloaded when changes are saved to it
- Distinguish between left and right alt/ctrl/shift keys
- Keyboard layout-aware
- Can have an indicator next to mouse (or not), with different colors for when idling, moving, pressing buttons, and scrolling.
- The indicator will re-position itself when the mouse is close to the edges of the screen so that it stays visible
- Configuration of keys is done in terms of key press and key release events, and whether the key events should be passed onto other apps or not.
  This allows for defining advanced key combos, but at the cost of added complexity for the user
  (not as simple as warpd, keynav and mouseable).
- The user defines modes. Each mode has its own key combo map.
- Each mode can have its own mouse and wheel configuration (initial velocity, max velocity, acceleration).
  This can be used to create "slow" or "fast" modes.
- A timeout can be set on a mode to switch to another mode after some idle time (this can be used for disabling Xxx after a while, hiding the indicator after a while, etc.)
- Grids.
- The major structural differences with mouseable and warpd are the way key combos are defined (key presses and key releases),
  the "create your own modes" approach, and the grids which are used for doing both mouseable-style "attach", mouseable-style "teleport",
  warpd-style "cutable grid", warpd-style "screen selection hints", and warpd-style "regular" hints.